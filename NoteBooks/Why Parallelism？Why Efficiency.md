# Why Parallelism？Why Efficiency?

**Why Parallelism？**

因为单颗核(core)的处理器性能增长遇到了瓶颈，若想要继续提高处理器的性能，策略是在处理器中放更多的核(core)。

同时为了让应用程序更高效地执行，我们需要利用好处理器中的多核(core)，即我们需要写并发程序。

**Why Efficiency?**

在多核(core)的处理器上，每一个核(core)并非都被高效利用到了，反而是大部分时间处于空闲中，这时我们说核(core)利用效率低下。

有没有什么具体的量化方法？

将处理器想象成一个正方形，其有一定的面积；将核(core)也想象成一个正方形，其也有一定面积且比处理器更小。

一颗处理器上核(core)越多越好，我们将核(core)放置在处理器上需要占用一定面积，那么在处理器面积固定的情况下我们将核(core)面积做得越小肯定越好。

* 一个非常重要的指标是**单位面积的性能**（performance per area），可用于衡量处理器的效率

* 同时还有能效，**单位能源的性能**（performance per Watt）

<hr>

本次课程主要讲解了多核(core)处理器的历史脉络以及随之发展的并发程序，并同时通过实验告知我们为何有时多核(core)执行任务与单核(core)执行任务的加速比并非理想。

![image-20250211221710786](https://raw.githubusercontent.com/cilinmengye/Resource-Warehourse/main/CloundIMG/image-20250211221710786.png)

此图横坐标为1970~2010年，纵坐标为处理器的功率密度（处理器表面每平方厘米产生的瓦特量）

Intel当时想要榨干单核(core)处理器的性能：

* 处理器更大的带宽：从4bit->64bit
* ILP（(Instruction-Level Parallelism）指令集并行技术
* 处理器更快的时钟频率：从10MHZ->3GHZ

当带宽和ILP都被快榨干时，时钟频率成为了Intel的买点，当时Intel甚至宣称时钟频率 == 速度。

但是正如上图所示，随着Intel不断推出高时钟频率的处理器，处理器的功率密度也越来越大了（处理器产生的热量越来越大），在2000年的处理器上甚至能够煎鸡蛋；图中橙色点为预测点，这些点的热量已经夸张到核反应堆中的热量了。也就是说再以指数形式提高处理器的时钟频率是不太可能了，热量无法散除。

Intel在技术上遇到了瓶颈，转而向让处理器拥有更多的核(core)进发。

![image](http://www.gotw.ca/images/CPU.png)

<center><font size=2>the free lunch is over — herb sutter</center>

> ILP 指令级并行，于《《计算机体系结构：量化研究方法》》一书的第三章重点提及：“大约 1985年之后的所有处理器都使用流水线来重叠指令的执行过程，以提高性能。由于指令可以并行执行，所以指令之间可能实现的这种重叠称为指令级并行(IP)。”
>
> 

<hr>

若一个任务A交给单核(core)需要花费56s完成，那么任务A交给4个核(core)完成可能需要34s。

为什么？为什么交给4个核(core)完成不是56/4 = 14s?

* 假设任务A包含了16个计算小任务，核(core)a，b，c，d可能分别被分配了1,1,1,13个小任务，如此核(core)d就成为了瓶颈，这被称为负载不均衡
* 想要达到负载均衡，需要执行一定的策略，需要一定额外时间
* 核(core)之前需要通信，有时甚至需要同步（等待他人完成），也需要一定额外时间。（想象一下1个人完成一个简单的小任务并汇报结果可能很快，但是150个人完成150个小任务并汇报结果并非按照预期所想，因为这150个人中每个人大部分时间是不工作的，而是等待）

# A Modern Multi-Core Processor







